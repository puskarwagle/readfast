<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Speed Reader</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
<style>
body {
  margin: 0;
  padding: 0;
  background: black;
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
  overflow: hidden;
  font-family: Arial, sans-serif;
}

#books {
  width: 20%;
  height: 100vh;
  background: rgba(255, 255, 255, 0.05);
  border-right: 2px solid #666;
  overflow-y: auto;
  padding: 20px;
  box-sizing: border-box;
}

#books h2 {
  color: white;
  font-size: 18px;
  margin: 0 0 20px 0;
  text-align: center;
}

.books-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 12px;
}

.book-card {
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid #666;
  border-radius: 12px;
  padding: 16px;
  cursor: pointer;
  transition: all 0.3s ease;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 8px;
  min-height: 100px;
}

.book-card:hover {
  background: rgba(255, 255, 255, 0.15);
  border-color: #999;
}

.book-card.active {
  background: rgba(255, 100, 100, 0.2);
  border-color: red;
}

.book-icon {
  font-size: 28px;
  flex-shrink: 0;
  margin-bottom: 4px;
}

.book-info {
  text-align: center;
  width: 100%;
}

.book-title {
  color: white;
  font-size: 14px;
  font-weight: 600;
  margin-bottom: 6px;
  overflow: hidden;
  text-overflow: ellipsis;
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
  white-space: normal;
  line-height: 1.3;
  width: 100%;
}

.book-type {
  color: #888;
  font-size: 10px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.loading-text {
  color: #999;
  text-align: center;
  padding: 40px 20px;
  font-size: 14px;
}

#main-container {
  width: 55%;
  height: 100vh;
  border-right: 2px solid #666;
  position: relative;
  overflow: hidden;
  cursor: grab;
  padding: 0 20px;
  box-sizing: border-box;
}

#main-container.dragging {
  cursor: grabbing;
}

#display-area {
  position: absolute;
  width: 100%;
  top: 50%;
  transform: translateY(-50%);
}

.row {
  position: absolute;
  height: 40px;
  width: 100%;
  font-family: Arial, sans-serif;
  font-size: 20px;
  line-height: 40px;
  white-space: nowrap;
}

.word {
  position: absolute;
  color: white;
  transition: color 0.3s ease;
}

.word.past {
  color: #999;
}

.word.future {
  color: #999;
}

.middle-letter {
  color: red;
  font-weight: bold;
}

#cursor {
  display: none;
}

#measure {
  position: absolute;
  visibility: hidden;
  white-space: nowrap;
  font-family: Arial, sans-serif;
  font-size: 20px;
}

#controls-panel {
  width: 25%;
  height: 100vh;
  background: rgba(255, 255, 255, 0.05);
  padding: 20px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 16px;
}

.control-card {
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid #666;
  border-radius: 8px;
  color: white;
  font-family: Arial, sans-serif;
  width: 125px;
  height: 100px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.control-card h3 {
  display: none;
}

button {
  background: transparent;
  color: white;
  border: none;
  padding: 0;
  border-radius: 8px;
  font-family: Arial, sans-serif;
  font-size: 24px;
  cursor: pointer;
  width: 125px;
  height: 100px;
  user-select: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
}

button:hover {
  background: rgba(255, 255, 255, 0.1);
}

/* Loading Overlay */
.loading-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.8);
  display: none;
  justify-content: center;
  align-items: center;
  flex-direction: column;
  z-index: 1000;
}

.loading-overlay.active {
  display: flex;
}

.loading-spinner {
  border: 4px solid rgba(255, 255, 255, 0.3);
  border-top: 4px solid white;
  border-radius: 50%;
  width: 50px;
  height: 50px;
  animation: spin 1s linear infinite;
  margin-bottom: 20px;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

.loading-overlay p {
  color: white;
  font-size: 16px;
}
</style>
</head>
<body>
<div id="books">
  <h2>üìö Your Books</h2>
  <div id="loading-books" class="loading-text">Loading books...</div>
  <div id="books-grid" class="books-grid"></div>
</div>

<div id="main-container">
  <div id="display-area" role="region" aria-label="Reading area"></div>
  <div id="cursor"></div>
</div>

<div id="controls-panel">
  <div class="control-card">
    <button id="toggle-mode" aria-label="Toggle between smooth and word mode">Smooth</button>
  </div>
  <div class="control-card">
    <button id="play-pause" aria-label="Play or pause reading">‚è∏</button>
  </div>
</div>

<div class="loading-overlay" id="loading-overlay">
  <div class="loading-spinner"></div>
  <p>Extracting text from PDF...</p>
</div>

<div id="measure"></div>
<div id="current-word" aria-live="polite" aria-atomic="true" style="position: absolute; left: -10000px;"></div>

<script>
'use strict';

// Set PDF.js worker
pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

// API Configuration
const API_URL = 'http://localhost:3000/api';

// =============================================================================
// CONFIGURATION
// =============================================================================

const CONFIG = {
  wpm: 250,
  wordSpacing: 8,
  linesAbove: 6,
  linesBelow: 6,
  rowHeight: 40,
  fontSize: 20,
  fontFamily: 'Arial, sans-serif',
  colors: {
    focus: 'white',
    past: '#999',
    future: '#999',
    accent: 'red'
  },
  animation: {
    frameTimeout: 120000,
  },
  scrolling: {
    wheelPixelDelta: 40,
    dragSensitivity: 1.0,
    autoResumeDelay: 0
  }
};

// Sample text as fallback
const SAMPLE_WORDS = [
  "Welcome", "to", "Speed", "Reader", "Select", "a", "book", "from", "the", "left",
  "sidebar", "to", "start", "reading", "You", "can", "toggle", "between", "smooth",
  "and", "word", "modes", "using", "the", "button", "below", "Use", "your", "mouse",
  "wheel", "or", "drag", "to", "manually", "scroll", "through", "the", "text",
  "Press", "the", "play", "button", "to", "start", "automatic", "reading"
];

// =============================================================================
// WORDMETRICS CLASS
// =============================================================================

class WordMetrics {
  constructor(words, config) {
    if (!Array.isArray(words) || words.length === 0) {
      throw new Error('WordMetrics: words must be a non-empty array');
    }

    this.words = words;
    this.config = config;
    this.measurementCache = new Map();
    this.measureElement = document.getElementById('measure');

    if (!this.measureElement) {
      throw new Error('WordMetrics: measure element not found');
    }

    this.wordPositions = this._calculateWordPositions();
  }

  _measureText(text, bold = false) {
    const cacheKey = `${text}_${bold}`;

    if (this.measurementCache.has(cacheKey)) {
      return this.measurementCache.get(cacheKey);
    }

    try {
      this.measureElement.textContent = text;
      this.measureElement.style.fontWeight = bold ? 'bold' : 'normal';
      const width = this.measureElement.offsetWidth;

      this.measurementCache.set(cacheKey, width);
      return width;
    } catch (error) {
      console.warn('WordMetrics: Error measuring text, using fallback', error);
      return text.length * 10;
    }
  }

  getWordWidth(word, isFocus = false) {
    if (!isFocus) {
      return this._measureText(word);
    }

    const len = word.length;
    const middleIndex = len <= 2 ? 0 : Math.floor(len / 2);

    const before = word.slice(0, middleIndex);
    const middle = word[middleIndex];
    const after = word.slice(middleIndex + 1);

    return this._measureText(before) +
           this._measureText(middle, true) +
           this._measureText(after);
  }

  getMiddleLetterOffset(word) {
    const len = word.length;
    const middleIndex = len <= 2 ? 0 : Math.floor(len / 2);

    let offset = 0;
    for (let i = 0; i < middleIndex; i++) {
      offset += this._measureText(word[i]);
    }

    const middleWidth = this._measureText(word[middleIndex], true);
    offset += middleWidth / 2;

    return offset;
  }

  _calculateWordPositions() {
    const positions = [];
    let cumulativePosition = 0;

    this.words.forEach((word, index) => {
      const width = this.getWordWidth(word, true);
      const middleLetterOffset = this.getMiddleLetterOffset(word);

      positions.push({
        word,
        index,
        startPosition: cumulativePosition,
        width,
        middleLetterOffset,
        centerPosition: cumulativePosition + middleLetterOffset
      });

      cumulativePosition += width + this.config.wordSpacing;
    });

    return positions;
  }

  getWordPositionData(index) {
    if (index < 0 || index >= this.wordPositions.length) {
      return null;
    }
    return this.wordPositions[index];
  }

  getWordCount() {
    return this.words.length;
  }

  getLastWordCenter() {
    if (this.wordPositions.length === 0) return 0;
    return this.wordPositions[this.wordPositions.length - 1].centerPosition;
  }

  clearCache() {
    this.measurementCache.clear();
  }
}

// =============================================================================
// RENDERENGINE CLASS
// =============================================================================

class RenderEngine {
  constructor(config, metrics) {
    this.config = config;
    this.metrics = metrics;

    this.elements = {
      displayArea: document.getElementById('display-area'),
      container: document.getElementById('main-container'),
      playPauseBtn: document.getElementById('play-pause'),
      currentWordAria: document.getElementById('current-word')
    };

    if (!this.elements.displayArea) {
      throw new Error('RenderEngine: display-area element not found');
    }
    if (!this.elements.container) {
      throw new Error('RenderEngine: main-container element not found');
    }

    // Account for container padding (20px on each side)
    const containerPadding = 40;
    this.containerWidth = this.elements.container.offsetWidth - containerPadding;
    this.centerX = this.containerWidth / 2;
  }

  _createWordElement(word, isFocus = false) {
    const span = document.createElement('span');
    span.className = 'word';

    if (isFocus) {
      const len = word.length;
      const middleIndex = len <= 2 ? 0 : Math.floor(len / 2);

      const before = word.slice(0, middleIndex);
      const middle = word[middleIndex];
      const after = word.slice(middleIndex + 1);

      span.innerHTML = before + '<span class="middle-letter">' + middle + '</span>' + after;
    } else {
      span.textContent = word;
    }

    return span;
  }

  _renderFocusLine(fragment, focusWordData, globalOffset, pastWords, futureWords) {
    const focusRowDiv = document.createElement('div');
    focusRowDiv.className = 'row';
    focusRowDiv.style.top = 'calc(50% - 20px)';

    pastWords.forEach(({ word, x }) => {
      const wordEl = this._createWordElement(word);
      wordEl.classList.add('past');
      wordEl.style.left = x + 'px';
      focusRowDiv.appendChild(wordEl);
    });

    const focusEl = this._createWordElement(focusWordData.word, true);
    const focusX = globalOffset + focusWordData.startPosition;
    focusEl.style.left = focusX + 'px';
    focusRowDiv.appendChild(focusEl);

    futureWords.forEach(({ word, x }) => {
      const wordEl = this._createWordElement(word);
      wordEl.classList.add('future');
      wordEl.style.left = x + 'px';
      focusRowDiv.appendChild(wordEl);
    });

    fragment.appendChild(focusRowDiv);
  }

  _renderPastLines(fragment, pastLines) {
    pastLines.forEach((lineWords, lineIndex) => {
      const rowDiv = document.createElement('div');
      rowDiv.className = 'row';

      const distanceFromFocus = pastLines.length - lineIndex;
      rowDiv.style.top = `calc(50% - ${20 + distanceFromFocus * this.config.rowHeight}px)`;

      let x = this.containerWidth - this.config.wordSpacing;
      for (let i = lineWords.length - 1; i >= 0; i--) {
        const { word } = lineWords[i];
        const width = this.metrics.getWordWidth(word);
        x -= width;

        // Skip words that would render off the left edge
        if (x >= 0) {
          const wordEl = this._createWordElement(word);
          wordEl.classList.add('past');
          wordEl.style.left = x + 'px';
          rowDiv.appendChild(wordEl);
        }

        x -= this.config.wordSpacing;
      }

      fragment.appendChild(rowDiv);
    });
  }

  _renderFutureLines(fragment, futureLines) {
    futureLines.forEach((lineWords, lineIndex) => {
      const rowDiv = document.createElement('div');
      rowDiv.className = 'row';

      rowDiv.style.top = `calc(50% + ${20 + lineIndex * this.config.rowHeight}px)`;

      let x = this.config.wordSpacing;
      for (let i = 0; i < lineWords.length; i++) {
        const { word } = lineWords[i];
        const width = this.metrics.getWordWidth(word);

        // Skip words that would render off the right edge
        if (x + width <= this.containerWidth) {
          const wordEl = this._createWordElement(word);
          wordEl.classList.add('future');
          wordEl.style.left = x + 'px';
          rowDiv.appendChild(wordEl);
        }

        x += width + this.config.wordSpacing;
      }

      fragment.appendChild(rowDiv);
    });
  }

  render(state) {
    if (!this.elements.displayArea) {
      return;
    }

    try {
      let currentFocusIndex;
      let globalOffset;
      let scrollOffset = state.scrollOffset;

      if (state.mode === 'smooth') {
        currentFocusIndex = 0;
        let minDistance = Math.abs(scrollOffset - this.metrics.wordPositions[0].centerPosition);

        for (let i = 1; i < this.metrics.wordPositions.length; i++) {
          const distance = Math.abs(scrollOffset - this.metrics.wordPositions[i].centerPosition);
          if (distance < minDistance) {
            minDistance = distance;
            currentFocusIndex = i;
          } else {
            break;
          }
        }
        globalOffset = this.centerX - scrollOffset;
      } else {
        currentFocusIndex = state.focusIndex;
        const focusData = this.metrics.getWordPositionData(currentFocusIndex);
        if (!focusData) return;
        scrollOffset = focusData.centerPosition;
        globalOffset = this.centerX - scrollOffset;
      }

      const focusWordData = this.metrics.getWordPositionData(currentFocusIndex);
      if (!focusWordData) return;

      if (this.elements.currentWordAria) {
        this.elements.currentWordAria.textContent = focusWordData.word;
      }

      const focusLinePastWords = [];
      const focusLineFutureWords = [];

      for (let i = currentFocusIndex - 1; i >= 0; i--) {
        const wordData = this.metrics.getWordPositionData(i);
        if (!wordData) break;

        const x = globalOffset + wordData.startPosition;
        const width = wordData.width;

        // Stop if word is completely off-screen to the left
        if (x + width < 0) break;

        focusLinePastWords.unshift({ word: wordData.word, index: i, x });
      }

      for (let i = currentFocusIndex + 1; i < this.metrics.getWordCount(); i++) {
        const wordData = this.metrics.getWordPositionData(i);
        if (!wordData) break;

        const x = globalOffset + wordData.startPosition;
        const width = wordData.width;

        if (x > this.containerWidth) break;

        focusLineFutureWords.push({ word: wordData.word, index: i, x });
      }

      const pastLines = this._calculatePastLines(
        currentFocusIndex - focusLinePastWords.length - 1
      );

      const futureLines = this._calculateFutureLines(
        currentFocusIndex + focusLineFutureWords.length + 1
      );

      const fragment = document.createDocumentFragment();

      this._renderPastLines(fragment, pastLines);
      this._renderFocusLine(fragment, focusWordData, globalOffset, focusLinePastWords, focusLineFutureWords);
      this._renderFutureLines(fragment, futureLines);

      this.elements.displayArea.innerHTML = '';
      this.elements.displayArea.appendChild(fragment);

    } catch (error) {
      console.error('RenderEngine: Error during render', error);
    }
  }

  _calculatePastLines(startIndex) {
    const pastLines = [];
    let currentLineWords = [];
    let lineWidth = 0;

    for (let i = startIndex; i >= 0; i--) {
      const wordData = this.metrics.getWordPositionData(i);
      if (!wordData) break;

      const word = wordData.word;
      const width = this.metrics.getWordWidth(word) + this.config.wordSpacing;

      if (lineWidth + width > this.containerWidth - this.config.wordSpacing && currentLineWords.length > 0) {
        pastLines.unshift([...currentLineWords]);
        currentLineWords = [];
        lineWidth = 0;

        if (pastLines.length >= this.config.linesAbove) {
          break;
        }
      }

      currentLineWords.unshift({ word, index: i });
      lineWidth += width;
    }

    if (currentLineWords.length > 0 && pastLines.length < this.config.linesAbove) {
      pastLines.unshift(currentLineWords);
    }

    return pastLines;
  }

  _calculateFutureLines(startIndex) {
    const futureLines = [];
    let currentLineWords = [];
    let lineWidth = 0;

    for (let i = startIndex; i < this.metrics.getWordCount(); i++) {
      const wordData = this.metrics.getWordPositionData(i);
      if (!wordData) break;

      const word = wordData.word;
      const width = this.metrics.getWordWidth(word) + this.config.wordSpacing;

      if (lineWidth + width > this.containerWidth - this.config.wordSpacing && currentLineWords.length > 0) {
        futureLines.push([...currentLineWords]);
        currentLineWords = [];
        lineWidth = 0;

        if (futureLines.length >= this.config.linesBelow) {
          break;
        }
      }

      currentLineWords.push({ word, index: i });
      lineWidth += width;
    }

    if (currentLineWords.length > 0 && futureLines.length < this.config.linesBelow) {
      futureLines.push(currentLineWords);
    }

    return futureLines;
  }

  updateModeIndicator(mode) {
    const toggleBtn = document.getElementById('toggle-mode');
    if (toggleBtn) {
      toggleBtn.textContent = mode === 'smooth' ? 'Smooth' : 'Word';
    }
  }

  updatePlayPauseButton(isPlaying) {
    if (this.elements.playPauseBtn) {
      this.elements.playPauseBtn.textContent = isPlaying ? '‚è∏' : '‚ñ∂';
    }
  }
}

// =============================================================================
// WORDMARQUEEENGINE CLASS
// =============================================================================

class WordMarqueeEngine {
  constructor(config, words) {
    if (!config) {
      throw new Error('WordMarqueeEngine: config is required');
    }
    if (!Array.isArray(words) || words.length === 0) {
      throw new Error('WordMarqueeEngine: words must be a non-empty array');
    }

    this.config = config;
    this.words = words;

    try {
      this.metrics = new WordMetrics(words, config);
      this.renderer = new RenderEngine(config, this.metrics);
    } catch (error) {
      throw new Error(`WordMarqueeEngine: Initialization failed - ${error.message}`);
    }

    this.state = {
      mode: 'smooth',
      isPlaying: false,
      scrollOffset: 0,
      focusIndex: 0,
      lastTimestamp: null
    };

    this.animationId = null;
    this.intervalId = null;

    const wordInterval = 60000 / this.config.wpm;
    const totalWidth = this.metrics.getLastWordCenter();
    const totalWords = this.metrics.getWordCount();
    this.pixelsPerMs = (totalWidth / totalWords) / wordInterval;

    this.dragState = {
      isDragging: false,
      startX: 0,
      startScrollOffset: 0,
      startFocusIndex: 0
    };

    this.autoResumeTimer = null;
    this.wasPlayingBeforeManualScroll = false;
    this.eventListeners = [];

    this._boundAnimateSmooth = this._animateSmooth.bind(this);
    this._boundAdvanceWord = this._advanceWord.bind(this);
    this._boundHandleWheel = this._handleWheel.bind(this);
    this._boundHandleMouseDown = this._handleMouseDown.bind(this);
    this._boundHandleMouseMove = this._handleMouseMove.bind(this);
    this._boundHandleMouseUp = this._handleMouseUp.bind(this);
  }

  loadNewText(words) {
    // Stop playback
    this.stop();

    // Clear old event listeners
    this.eventListeners.forEach(({ target, event, handler }) => {
      target.removeEventListener(event, handler);
    });
    this.eventListeners = [];

    // Update words
    this.words = words;

    // Recreate metrics and renderer
    this.metrics = new WordMetrics(words, this.config);
    this.renderer = new RenderEngine(this.config, this.metrics);

    // Reset state
    this.state = {
      mode: this.state.mode, // Preserve mode
      isPlaying: false,
      scrollOffset: 0,
      focusIndex: 0,
      lastTimestamp: null
    };

    // Recalculate speed
    const wordInterval = 60000 / this.config.wpm;
    const totalWidth = this.metrics.getLastWordCenter();
    const totalWords = this.metrics.getWordCount();
    this.pixelsPerMs = (totalWidth / totalWords) / wordInterval;

    // Re-setup event listeners
    this.setupEventListeners();

    // Render initial state
    this.renderer.render(this.state);
    this.renderer.updateModeIndicator(this.state.mode);
    this.renderer.updatePlayPauseButton(false);

    console.log('Text loaded:', words.length, 'words');
  }

  start() {
    if (this.state.isPlaying) {
      return;
    }

    try {
      if (this.autoResumeTimer) {
        clearTimeout(this.autoResumeTimer);
        this.autoResumeTimer = null;
      }

      this.state.isPlaying = true;
      this.renderer.updatePlayPauseButton(true);

      if (this.state.mode === 'smooth') {
        this.state.lastTimestamp = null;
        this.animationId = requestAnimationFrame(this._boundAnimateSmooth);
      } else {
        const wordInterval = 60000 / this.config.wpm;
        this.intervalId = setInterval(this._boundAdvanceWord, wordInterval);
      }
    } catch (error) {
      console.error('WordMarqueeEngine: Error starting playback', error);
      this.state.isPlaying = false;
    }
  }

  stop() {
    this.state.isPlaying = false;
    this.renderer.updatePlayPauseButton(false);

    if (this.animationId) {
      cancelAnimationFrame(this.animationId);
      this.animationId = null;
    }

    if (this.intervalId) {
      clearInterval(this.intervalId);
      this.intervalId = null;
    }

    this.state.lastTimestamp = null;
  }

  toggleMode() {
    const wasPlaying = this.state.isPlaying;
    this.stop();

    try {
      if (this.state.mode === 'smooth') {
        this.state.mode = 'word';

        for (let i = 0; i < this.metrics.wordPositions.length; i++) {
          const wordData = this.metrics.getWordPositionData(i);
          if (wordData && this.state.scrollOffset >= wordData.centerPosition) {
            this.state.focusIndex = i;
          } else {
            break;
          }
        }
      } else {
        this.state.mode = 'smooth';

        const wordData = this.metrics.getWordPositionData(this.state.focusIndex);
        if (wordData) {
          this.state.scrollOffset = wordData.centerPosition;
        }
      }

      this.renderer.updateModeIndicator(this.state.mode);
      this.renderer.render(this.state);

      if (wasPlaying) {
        this.start();
      }
    } catch (error) {
      console.error('WordMarqueeEngine: Error toggling mode', error);
    }
  }

  togglePlayPause() {
    if (this.autoResumeTimer) {
      clearTimeout(this.autoResumeTimer);
      this.autoResumeTimer = null;
    }
    this.wasPlayingBeforeManualScroll = false;

    if (this.state.isPlaying) {
      this.stop();
    } else {
      this.start();
    }
  }

  _animateSmooth(timestamp) {
    if (!this.state.lastTimestamp) {
      this.state.lastTimestamp = timestamp;
    }

    const deltaTime = timestamp - this.state.lastTimestamp;
    this.state.lastTimestamp = timestamp;

    this.state.scrollOffset += this.pixelsPerMs * deltaTime;

    const lastWordCenter = this.metrics.getLastWordCenter();
    if (this.state.scrollOffset >= lastWordCenter) {
      this.state.scrollOffset = lastWordCenter;
      this.renderer.render(this.state);
      this.stop();
      return;
    }

    try {
      this.renderer.render(this.state);

      if (this.state.isPlaying && this.state.mode === 'smooth') {
        this.animationId = requestAnimationFrame(this._boundAnimateSmooth);
      }
    } catch (error) {
      console.error('WordMarqueeEngine: Error in smooth animation', error);
      this.stop();
    }
  }

  _advanceWord() {
    try {
      if (this.state.focusIndex < this.metrics.getWordCount() - 1) {
        this.state.focusIndex++;
        this.renderer.render(this.state);
      } else {
        this.stop();
      }
    } catch (error) {
      console.error('WordMarqueeEngine: Error advancing word', error);
      this.stop();
    }
  }

  _startAutoResumeTimer() {
    if (this.autoResumeTimer) {
      clearTimeout(this.autoResumeTimer);
      this.autoResumeTimer = null;
    }

    if (this.wasPlayingBeforeManualScroll) {
      this.autoResumeTimer = setTimeout(() => {
        this.autoResumeTimer = null;
        this.wasPlayingBeforeManualScroll = false;
        this.start();
      }, this.config.scrolling.autoResumeDelay);
    }
  }

  _handleManualScrollStart() {
    if (!this.autoResumeTimer && this.state.isPlaying) {
      this.wasPlayingBeforeManualScroll = true;
    }

    if (this.state.isPlaying) {
      this.stop();
    }

    this._startAutoResumeTimer();
  }

  _handleWheel(event) {
    event.preventDefault();

    this._handleManualScrollStart();

    try {
      if (this.state.mode === 'smooth') {
        const delta = -Math.sign(event.deltaY) * this.config.scrolling.wheelPixelDelta;

        this.state.scrollOffset += delta;

        this.state.scrollOffset = Math.max(0, Math.min(
          this.state.scrollOffset,
          this.metrics.getLastWordCenter()
        ));

        this.renderer.render(this.state);
      } else {
        if (event.deltaY > 0) {
          if (this.state.focusIndex > 0) {
            this.state.focusIndex--;
            this.renderer.render(this.state);
          }
        } else if (event.deltaY < 0) {
          if (this.state.focusIndex < this.metrics.getWordCount() - 1) {
            this.state.focusIndex++;
            this.renderer.render(this.state);
          }
        }
      }
    } catch (error) {
      console.error('WordMarqueeEngine: Error handling wheel event', error);
    }
  }

  _handleMouseDown(event) {
    if (event.target.tagName === 'BUTTON') {
      return;
    }

    this.dragState.isDragging = true;
    this.dragState.startX = event.clientX;
    this.dragState.startScrollOffset = this.state.scrollOffset;
    this.dragState.startFocusIndex = this.state.focusIndex;

    this.renderer.elements.container.classList.add('dragging');

    this._handleManualScrollStart();
  }

  _handleMouseMove(event) {
    if (!this.dragState.isDragging) {
      return;
    }

    this._startAutoResumeTimer();

    try {
      const deltaX = event.clientX - this.dragState.startX;

      if (this.state.mode === 'smooth') {
        const dragDelta = -deltaX * this.config.scrolling.dragSensitivity;

        this.state.scrollOffset = this.dragState.startScrollOffset + dragDelta;

        this.state.scrollOffset = Math.max(0, Math.min(
          this.state.scrollOffset,
          this.metrics.getLastWordCenter()
        ));

        this.renderer.render(this.state);
      } else {
        const wordThreshold = 30;
        const wordDelta = -Math.floor(deltaX / wordThreshold);

        const newFocusIndex = this.dragState.startFocusIndex + wordDelta;

        const clampedIndex = Math.max(0, Math.min(
          newFocusIndex,
          this.metrics.getWordCount() - 1
        ));

        if (clampedIndex !== this.state.focusIndex) {
          this.state.focusIndex = clampedIndex;
          this.renderer.render(this.state);
        }
      }
    } catch (error) {
      console.error('WordMarqueeEngine: Error handling mouse move', error);
    }
  }

  _handleMouseUp(event) {
    if (!this.dragState.isDragging) {
      return;
    }

    this.dragState.isDragging = false;

    this.renderer.elements.container.classList.remove('dragging');

    if (this.state.mode === 'word') {
      const wordData = this.metrics.getWordPositionData(this.state.focusIndex);
      if (wordData) {
        this.state.scrollOffset = wordData.centerPosition;
      }
    }
  }

  _addEventListener(target, event, handler) {
    target.addEventListener(event, handler);
    this.eventListeners.push({ target, event, handler });
  }

  setupEventListeners() {
    const toggleModeBtn = document.getElementById('toggle-mode');
    const playPauseBtn = document.getElementById('play-pause');
    const container = this.renderer.elements.container;

    if (toggleModeBtn) {
      this._addEventListener(toggleModeBtn, 'click', () => this.toggleMode());
    }

    if (playPauseBtn) {
      this._addEventListener(playPauseBtn, 'click', () => this.togglePlayPause());
    }

    this._addEventListener(document, 'keydown', (e) => {
      if (e.code === 'Space') {
        e.preventDefault();
        this.togglePlayPause();
      }
    });

    if (container) {
      this._addEventListener(container, 'wheel', this._boundHandleWheel, { passive: false });
      this._addEventListener(container, 'mousedown', this._boundHandleMouseDown);
    }

    this._addEventListener(document, 'mousemove', this._boundHandleMouseMove);
    this._addEventListener(document, 'mouseup', this._boundHandleMouseUp);
  }

  destroy() {
    this.stop();

    if (this.autoResumeTimer) {
      clearTimeout(this.autoResumeTimer);
      this.autoResumeTimer = null;
    }

    this.eventListeners.forEach(({ target, event, handler }) => {
      target.removeEventListener(event, handler);
    });
    this.eventListeners = [];

    this.dragState.isDragging = false;
    if (this.renderer && this.renderer.elements.container) {
      this.renderer.elements.container.classList.remove('dragging');
    }

    if (this.metrics) {
      this.metrics.clearCache();
    }

    this.metrics = null;
    this.renderer = null;
    this.state = null;
  }
}

// =============================================================================
// BOOK LOADING FUNCTIONS
// =============================================================================

let currentBook = null;
let engine = null;

async function loadBooks() {
  const loadingBooks = document.getElementById('loading-books');
  const booksGrid = document.getElementById('books-grid');

  try {
    loadingBooks.style.display = 'block';
    booksGrid.innerHTML = '';

    const response = await fetch(`${API_URL}/books`);
    if (!response.ok) throw new Error('Failed to fetch books');

    const books = await response.json();
    loadingBooks.style.display = 'none';

    if (books.length === 0) {
      booksGrid.innerHTML = '<p class="loading-text">No books found in the books folder</p>';
      return;
    }

    books.forEach(book => {
      const bookCard = createBookCard(book);
      booksGrid.appendChild(bookCard);
    });
  } catch (error) {
    console.error('Error loading books:', error);
    loadingBooks.style.display = 'none';
    booksGrid.innerHTML = '<p class="loading-text">Error loading books. Make sure the server is running.</p>';
  }
}

function createBookCard(book) {
  const card = document.createElement('div');
  card.className = 'book-card';
  card.dataset.filename = book.filename;

  const icon = book.type === 'pdf' ? 'üìï' : 'üìò';

  card.innerHTML = `
    <div class="book-icon">${icon}</div>
    <div class="book-info">
      <div class="book-title">${book.title}</div>
      <div class="book-type">${book.type}</div>
    </div>
  `;

  card.addEventListener('click', () => selectBook(book, card));

  return card;
}

async function selectBook(book, cardElement) {
  if (book.type === 'epub') {
    alert('EPUB support coming soon! Please select a PDF file.');
    return;
  }

  // Update active state
  document.querySelectorAll('.book-card').forEach(card => card.classList.remove('active'));
  cardElement.classList.add('active');

  const loadingOverlay = document.getElementById('loading-overlay');
  loadingOverlay.classList.add('active');

  try {
    const text = await extractPDFText(book.filename);
    const words = text.split(' ').filter(word => word.length > 0);

    if (engine) {
      engine.loadNewText(words);
    }

    currentBook = book;
    loadingOverlay.classList.remove('active');
  } catch (error) {
    console.error('Error loading book:', error);
    loadingOverlay.classList.remove('active');
    alert('Failed to extract text from PDF. Please try another book.');
  }
}

async function extractPDFText(filename) {
  try {
    const response = await fetch(`${API_URL}/books/${filename}/extract`);

    if (response.ok) {
      const data = await response.json();
      return cleanText(data.text);
    }

    return await extractPDFTextClientSide(filename);
  } catch (error) {
    console.error('Server-side extraction failed, trying client-side:', error);
    return await extractPDFTextClientSide(filename);
  }
}

async function extractPDFTextClientSide(filename) {
  const pdfUrl = `${API_URL}/books/${filename}`;
  const loadingTask = pdfjsLib.getDocument(pdfUrl);
  const pdf = await loadingTask.promise;

  let fullText = '';

  for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
    const page = await pdf.getPage(pageNum);
    const textContent = await page.getTextContent();
    const pageText = textContent.items.map(item => item.str).join(' ');
    fullText += pageText + ' ';
  }

  return cleanText(fullText);
}

function cleanText(text) {
  return text
    .replace(/\s+/g, ' ')
    .replace(/\n+/g, ' ')
    .trim();
}

// =============================================================================
// INITIALIZATION
// =============================================================================

(function init() {
  try {
    engine = new WordMarqueeEngine(CONFIG, SAMPLE_WORDS);
    engine.setupEventListeners();
    engine.renderer.render(engine.state);

    window.marqueeEngine = engine;

    // Load books from server
    loadBooks();

    console.log('Speed Reader initialized successfully');
  } catch (error) {
    console.error('Failed to initialize Speed Reader:', error);

    const displayArea = document.getElementById('display-area');
    if (displayArea) {
      displayArea.innerHTML = '<div style="color: white; padding: 20px;">Error initializing reader. Please check console.</div>';
    }
  }
})();

</script>
</body>
</html>
